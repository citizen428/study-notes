<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>The Typeclassopedia - A summary</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-07-31 16:56:13 CEST"/>
<meta name="author" content="Michael Kohl"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>

<link rel="stylesheet" type="text/css" href="style.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="content">

<h1 class="title">The Typeclassopedia - A summary</h1>
<p>This is a summary of Brent Yorgey's excellent article "The
Typeclassopedia", originally published in issue <a href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">#13</a> of "<a href="http://themonadreader.wordpress.com/">The Monad Reader</a>".
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Functor </a></li>
<li><a href="#sec-2">2 Pointed </a></li>
<li><a href="#sec-3">3 Applicative </a></li>
<li><a href="#sec-4">4 Monad </a></li>
<li><a href="#sec-5">5 Monoid </a></li>
<li><a href="#sec-6">6 Foldable </a></li>
<li><a href="#sec-7">7 Traversable </a></li>
<li><a href="#sec-8">8 Category </a></li>
<li><a href="#sec-9">9 Arrow </a></li>
<li><a href="#sec-10">10 ArrowChoice </a></li>
<li><a href="#sec-11">11 ArrowApply </a></li>
<li><a href="#sec-12">12 ArrowLoop </a></li>
<li><a href="#sec-13">13 Comonad </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Functor </h2>
<div class="outline-text-2" id="text-1">

<ul>
<li id="sec-1_1">"container" with ability to apply a function to every element <br/>
   <code>fmap</code> applies function to each element of the container without
   altering the structure of the container
</li>
</ul>
<ul>
<li id="sec-1_2">a functor represents some sort of "computational context" <br/>
   <code>fmap</code> applies function without altering context
</li>
</ul>
<ul>
<li id="sec-1_3">example: a list and the <code>map</code> function <br/>
</li>
</ul>
<ul>
<li id="sec-1_4">exported by the <code>Prelude</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5">instances <br/>
<ul>
<li id="sec-1_5_1"><code>[]</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_2"><code>Maybe</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_3"><code>Either e</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_4"><code>IO</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_5"><code>Tree</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_6"><code>Map</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_7"><code>Sequence</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_8"><code>Stream</code> <br/>
</li>
</ul>
<ul>
<li id="sec-1_5_9"><code>Set</code> is NOT a functor in Haskell because of the <code>Ord</code> type constraint <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-1_6">laws <br/>
<ul>
<li id="sec-1_6_1"><code>fmap id = id</code> <br/>
    mapping the identity has no effect
</li>
</ul>
<ul>
<li id="sec-1_6_2"><code>fmap (g . h) = fmap g . fmap h</code> <br/>
    mapping a function composition has the same effect as first mapping
    one and then the other function
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-1_7"><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code> <br/>
   <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>
   the extra parenthesis show that <code>fmap</code> transforms a "normal" function
   into one operating on containers/contexts =&gt; "lift"
</li>
</ul>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Pointed </h2>
<div class="outline-text-2" id="text-2">

<ul>
<li id="sec-2_1">not in the standard libraries, but in <code>category-extras</code> <br/>
</li>
</ul>
<ul>
<li id="sec-2_2">represents pointed functors <br/>
</li>
</ul>
<ul>
<li id="sec-2_3">useful for understanding <code>Applicative</code> and <code>Monad</code> <br/>
</li>
</ul>
<ul>
<li id="sec-2_4">Pointed represents additional ability for putting value in default context <br/>
</li>
</ul>
<ul>
<li id="sec-2_5">defines a <code>pure</code> function aka singleton, return, unit, point <br/>
   for example <code>Just</code> for <code>Maybe</code>
</li>
</ul>
<ul>
<li id="sec-2_6">most standard <code>Functor</code> instances could be instances of <code>Pointed</code> <br/>
</li>
</ul>
<ul>
<li id="sec-2_7">law <br/>
<ul>
<li id="sec-2_7_1"><code>fmap g . pure = pure . g</code> <br/>
</li>
</ul>
<ul>
<li id="sec-2_7_2">impossible to write an instance that does not satisfy it <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Applicative </h2>
<div class="outline-text-2" id="text-3">

<ul>
<li id="sec-3_1">defined in <code>Control.Applicative</code> <br/>
</li>
</ul>
<ul>
<li id="sec-3_2">newer addition to standard Haskell type classes <br/>
</li>
</ul>
<ul>
<li id="sec-3_3">applicative functors are exactly in between <code>Functor</code> and <code>Monad</code> <br/>
</li>
</ul>
<ul>
<li id="sec-3_4">every <code>Applicative</code> instance must also be a <code>Functor</code> <br/>
</li>
</ul>
<ul>
<li id="sec-3_5">adds one capability to <code>Pointed</code>, applying a function which itself is in a context <br/>
   <code>&lt;*&gt;</code> is basically just function application within a context
</li>
</ul>
<ul>
<li id="sec-3_6">laws <br/>
<ul>
<li id="sec-3_6_1"><code>fmap g x = pure g &lt;*&gt; x</code> <br/>
    <code>g &lt;$> x = pure g &lt;*&gt; x</code>

<p>
    mapping a function <code>g</code> over a context <code>x</code> is the same as injecting <code>g</code>
    into the context with <code>pure</code> and then applying it to <code>x</code> with <code>&lt;*&gt;</code>
</p></li>
</ul>
<ul>
<li id="sec-3_6_2">other laws relate to <code>pure</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-3_7">instances <br/>
<ul>
<li id="sec-3_7_1">most instances of <code>Functor</code> <br/>
</li>
</ul>
<ul>
<li id="sec-3_7_2"><code>Const</code> type constructor (defined in <code>Applicative</code>) <br/>
</li>
</ul>
<ul>
<li id="sec-3_7_3"><code>WrappedMonad</code> and <code>WrappedArrow</code> newtypes <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Monad </h2>
<div class="outline-text-2" id="text-4">

<ul>
<li id="sec-4_1">special because Haskell made them framework for I/O operations <br/>
</li>
</ul>
<ul>
<li id="sec-4_2">special because of syntactic sugar (do-notation) <br/>
</li>
</ul>
<ul>
<li id="sec-4_3">older than <code>Applicative</code> and <code>Arrow</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_4">exported by the <code>Prelude</code>, many utility functions in <code>Control.Monad</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_5">additional instances in <code>Control.Monad.Instances</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_6">methods <br/>
<ul>
<li id="sec-4_6_1"><code>return</code> is the same as <code>pure</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_6_2"><code>(&gt;&gt;)</code> comes with a default implementation <br/>
</li>
</ul>
<ul>
<li id="sec-4_6_3"><code>fail</code> is a hack with no place in the <code>Monad</code> class <br/>
</li>
</ul>
<ul>
<li id="sec-4_6_4"><code>(&gt;&gt;=)</code> aka <code>bind</code> makes <code>Monad</code> more powerful than <code>Applicative</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_7"><code>(&gt;&gt;=)</code> combines 2 computations into 1 larger computation <br/>
</li>
</ul>
<ul>
<li id="sec-4_8">structure of a monadic computation can change depending on intermediate values; more powerful than <code>Applicative</code> where structure is fixed <br/>
</li>
</ul>
<ul>
<li id="sec-4_9">instances <br/>
<ul>
<li id="sec-4_9_1"><code>Identity</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_2"><code>Maybe</code> models computations which may fail <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_3"><code>[]</code> similar to <code>Applicative</code>, models non-deterministic computations <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_4"><code>IO</code> implemented in compiler specific ways; allows to build up values representing possibly effectful computations <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_5"><code>((-&gt;) e)</code> aka "reader monad" for computations with a read-only environment <code>e</code> (see <code>Control.Monad.Reader</code>) <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_6"><code>Writer</code> (defined in <code>Control.Monad.Writer</code>) collects information as computation progresses <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_7"><code>State</code> (<code>Control.Monad.State</code>) representes stateful computations <br/>
</li>
</ul>
<ul>
<li id="sec-4_9_8"><code>Cont</code> (<code>Control.Monad.Cont</code>) models computations in CPS; has been called the "mother of all monads" <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_10">utility functions <br/>
<ul>
<li id="sec-4_10_1"><code>join</code> removes one level of monadic structure <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_2"><code>liftM</code> is like <code>fmap</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_3"><code>ap</code> is equivalent to <code>&lt;*&gt;</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_4"><code>sequence</code> combines list of computations into one which collects a list of their results <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_5"><code>replicateM</code> is a combination of <code>replicate</code> and <code>sequence</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_6"><code>mapM</code> maps first argument over second and sequences results <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_7"><code>(=&lt;&lt;)</code> is <code>(&gt;&gt;=)</code> with reversed arguments <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_8"><code>(&gt;=&gt;)</code> is like function composition but with an extra <code>m</code> on the result type of the functions and swapped arguments <br/>
</li>
</ul>
<ul>
<li id="sec-4_10_9">many of the above function have underscore variants (like <code>mapM_</code> that are only used for side-effects and throw away the results of the computations) <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_11">laws <br/>
<ul>
<li id="sec-4_11_1"><code>return a &gt;&gt;= k = k a</code> (injecting and binding is the same as applying) <br/>
</li>
</ul>
<ul>
<li id="sec-4_11_2"><code>m &gt;&gt;= return = m</code> (binding and returning leaves <code>m</code> unchanged) <br/>
</li>
</ul>
<ul>
<li id="sec-4_11_3"><code>m &gt;&gt;= (\x -&gt; kx &gt;&gt;= h) = (m &gt;&gt;= k) &gt;&gt;= h</code> (<code>(&gt;&gt;=)</code> is sort of associative) <br/>
</li>
</ul>
<ul>
<li id="sec-4_11_4"><code>fmap f xs = xs &gt;&gt;= return . f = liftM f xs</code> (ensures that <code>fmap</code> and <code>liftM</code> are the same for types which are instances of <code>Functor</code> and <code>Monad</code>) <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_12">alternative laws using <code>(&gt;=&gt;)</code> <br/>
<ul>
<li id="sec-4_12_1"><code>return &gt;=&gt; g = g</code> (<code>return</code> is the identity of <code>(&gt;=&gt;)</code>) <br/>
</li>
</ul>
<ul>
<li id="sec-4_12_2"><code>g &gt;=&gt; return = g</code> (same as above) <br/>
</li>
</ul>
<ul>
<li id="sec-4_12_3"><code>(g &gt;=&gt; h) &gt;=&gt; k = g &gt;=&gt; (h &gt;=&gt; k)</code> (<code>(&gt;=&gt;)</code> is associative) <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_13">do-notation <br/>
<ul>
<li id="sec-4_13_1">syntatactic sugar for "imperative style" programming <br/>
</li>
</ul>
<ul>
<li id="sec-4_13_2">do-blocks are recursively translated into monad operations <br/>
</li>
</ul>
<ul>
<li id="sec-4_13_3">plays strongly on "computational context" interpretation rather than "container" interpretation <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_14">monad transformers <br/>
<ul>
<li id="sec-4_14_1">used for combining monads into a new monad <br/>
</li>
</ul>
<ul>
<li id="sec-4_14_2"><code>State</code>, <code>ReaderT</code>, <code>ErrorT</code> and (soon) <code>MaybeT</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_14_3">build composite monads "inside out" (see lambdabot's <code>@unmtl</code> command) <br/>
</li>
</ul>
<ul>
<li id="sec-4_14_4">all monad transformers implement the <code>MonadTrans</code> typeclass (<code>Control.Monad.Trans</code>) <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-4_15"><code>MonadFix</code> <br/>
<ul>
<li id="sec-4_15_1">describes monads which support the fixpoint operation <code>mfix</code> <br/>
</li>
</ul>
<ul>
<li id="sec-4_15_2"><code>mfix :: (a -&gt; m a) -&gt; m a</code>: allows output of monadic computation to be defined via recursion <br/>
</li>
</ul>
<ul>
<li id="sec-4_15_3"><code>mdo</code> is a "recursive do" notation <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Monoid </h2>
<div class="outline-text-2" id="text-5">

<ul>
<li id="sec-5_1">a set <code>S</code> with an associative binary operation <code>⊕</code> and an identity element in respect to that operation <br/>
</li>
</ul>
<ul>
<li id="sec-5_2">examples: <br/>
<ul>
<li id="sec-5_2_1">natural numbers under addition <br/>
</li>
</ul>
<ul>
<li id="sec-5_2_2">integers under multiplication <br/>
</li>
</ul>
<ul>
<li id="sec-5_2_3">boolean values under conjuction and disjunction <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-5_3">defines several functions <br/>
<ul>
<li id="sec-5_3_1"><code>mempty</code> is the identity element <br/>
</li>
</ul>
<ul>
<li id="sec-5_3_2"><code>mappend</code> is the binary operation <br/>
</li>
</ul>
<ul>
<li id="sec-5_3_3"><code>mconcat</code>'s default implementations folds <code>mappend</code>, usually sufficient <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-5_4">laws <br/>
<ul>
<li id="sec-5_4_1"><code>mempty `mappend` x = x</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_4_2"><code>x `mappend` mempty = x</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_4_3"><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-5_5">instances <br/>
<ul>
<li id="sec-5_5_1">defined in <code>Data.Monoid</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_2"><code>[a]</code>, with <code>mempty = []</code> and <code>mappend = (++)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_3"><code>Sum</code> and <code>Product</code> newtype wrappers for numeric types under addition/multiplication <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_4"><code>Any</code> and <code>All</code> as newtype wrappers for <code>Bool</code> under disjunction and conjunction <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_5"><code>Maybe</code>, as well as <code>First</code> and <code>Last</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_6"><code>Endo a</code>, newtype wrapper fo <code>a -&gt; a</code>, which form a monoid under composition <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_7"><code>Ordering = LT | EQ | GT</code> with <code>mempty = EQ</code> and <code>mconcat (zipWith compare xs ys)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-5_5_8">instances for container types <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-5_6">other monoidial classes <br/>
<ul>
<li id="sec-5_6_1"><code>Alternative</code> for <code>Applicative</code> functors with monoid structure <br/>
</li>
</ul>
<ul>
<li id="sec-5_6_2"><code>MonadPlus</code> for monads with a monoid structure (monads which support "choice and failure") <br/>
</li>
</ul>
<ul>
<li id="sec-5_6_3"><code>ArrowZero</code> and <code>ArrowPlus</code> for representing <code>Arrows</code> with monoid structure <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Foldable </h2>
<div class="outline-text-2" id="text-6">

<ul>
<li id="sec-6_1">defined in <code>Data.Foldable</code> <br/>
</li>
</ul>
<ul>
<li id="sec-6_2">for containers that can be "folded" into a summary value <br/>
</li>
</ul>
<ul>
<li id="sec-6_3">container-agnostic <br/>
</li>
</ul>
<ul>
<li id="sec-6_4">to make an instance either implement <code>foldMap</code> or <code>foldr</code> <br/>
<ul>
<li id="sec-6_4_1"><code>foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m</code> <br/>
</li>
</ul>
<ul>
<li id="sec-6_4_2"><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-6_5">instances <br/>
<ul>
<li id="sec-6_5_1"><code>List</code> <br/>
</li>
</ul>
<ul>
<li id="sec-6_5_2"><code>Maybe</code> <br/>
</li>
</ul>
<ul>
<li id="sec-6_5_3"><code>Array</code> <br/>
</li>
</ul>
<ul>
<li id="sec-6_5_4">containers like <code>Map</code>, <code>Set</code>, <code>Tree</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-6_6">module contains generalized versions of <code>Prelude</code> functions like <code>concat</code>, <code>any</code>, <code>all</code> etc. <br/>
</li>
</ul>
<ul>
<li id="sec-6_7">generic functions to work with <code>Applicative</code> or <code>Monad</code> instances like <code>traverse_</code>, <code>sequenceA_</code> etc. <br/>
</li>
</ul>
<ul>
<li id="sec-6_8"><code>Foldable</code> operations forget structure of container type, but <code>Traversable</code> will preserve it <br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Traversable </h2>
<div class="outline-text-2" id="text-7">

<ul>
<li id="sec-7_1">defined in <code>Data.Traversable</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_2">every <code>Traversable</code> is a foldable functor <br/>
</li>
</ul>
<ul>
<li id="sec-7_3">instances only need to implement <code>traverse</code> and <code>sequenceA</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_4"><code>sequenceA</code> is the key method of <code>Traversable</code> <br/>
<ul>
<li id="sec-7_4_1"><code>sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_4_2">answers the question when we can commute two functors <br/>
</li>
</ul>
<ul>
<li id="sec-7_4_3">ability to compose two mondas depends crucially on this <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-7_5">instances <br/>
<ul>
<li id="sec-7_5_1"><code>[]</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_5_2"><code>Maybe</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_5_3"><code>Map</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_5_4"><code>Tree</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_5_5"><code>Sequence</code> <br/>
</li>
</ul>
<ul>
<li id="sec-7_5_6"><code>Set</code> is not <code>Traversable</code> even though it's <code>Foldable</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-7_6"><code>Traversable</code> and <code>Functor</code> instances are almost identical, but <code>Traversable</code> takes place within an <code>Applicative</code> context <br/>
</li>
</ul>
<ul>
<li id="sec-7_7">any <code>Traversable</code> functor is also <code>Foldable</code> and a <code>Functor</code>, both classes can be implemented only with methods from <code>Traversable</code> <br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Category </h2>
<div class="outline-text-2" id="text-8">

<ul>
<li id="sec-8_1">fairly new addition to Haskell standard library <br/>
</li>
</ul>
<ul>
<li id="sec-8_2">generalizes notion of function compositions to general "morphisms" <br/>
</li>
</ul>
<ul>
<li id="sec-8_3">defined in <code>Control.Category</code> <br/>
</li>
</ul>
<ul>
<li id="sec-8_4">instance of <code>Category</code> should be something of kind <code>* -&gt; * -&gt; *</code> (a type constructor which takes 2 type arguments) <br/>
</li>
</ul>
<ul>
<li id="sec-8_5">instances <br/>
<ul>
<li id="sec-8_5_1"><code>(-&gt;)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-8_5_2"><code>Kleisli</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-8_6">methods <br/>
<ul>
<li id="sec-8_6_1"><code>id :: cat a a</code> <br/>
</li>
</ul>
<ul>
<li id="sec-8_6_2"><code>(.) :: cat b c -&gt; cat a b -&gt; cat a c</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-8_7">law <br/>
<ul>
<li id="sec-8_7_1"><code>id</code> and <code>(.)</code> should form a monoid (<code>id</code> should be identity of <code>(.)</code> and <code>(.)</code> should be associative) <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-8_8">two additional operators <br/>
<ul>
<li id="sec-8_8_1"><code>(&lt;&lt;&lt;)</code>, a synonym for <code>(.)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-8_8_2"><code>(&gt;&gt;&gt;)</code>, is <code>(.)</code> with its arguments reversed <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-8_9">can only represent categories whose objects are objects of <code>Hask</code>, more general category treatment in <code>category-extras</code> <br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Arrow </h2>
<div class="outline-text-2" id="text-9">

<ul>
<li id="sec-9_1">another abstraction of computation, like <code>Monad</code> and <code>Applicative</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_2">type of an <code>Arrow</code> computation reflects both its input and output <br/>
</li>
</ul>
<ul>
<li id="sec-9_3"><code>Arrows</code> generalize functions, may represent some sort of "effectful" computation <br/>
</li>
</ul>
<ul>
<li id="sec-9_4"><code>Category</code> class constraint, so we get identity arrows and arrow composition for free <br/>
</li>
</ul>
<ul>
<li id="sec-9_5">methods that need to be implement <br/>
<ul>
<li id="sec-9_5_1"><code>arr :: (b -&gt; c) -&gt; (b ~&gt; c)</code>: takes any function <code>b -&gt; c</code> and turns it into a generalized arrow <code>b ~&gt; c</code>. Says we can treat any function as an arrow. <br/>
</li>
</ul>
<ul>
<li id="sec-9_5_2"><code>first :: (b ~&gt; c) -&gt; ((b, d) ~&gt; (c, d))</code>: turns any arrow from <code>b</code> to <code>c</code> into an arrow from <code>(b,d)</code> to <code>(c,d)</code>. Processes first element of a tuple while leaving the second one unchanged <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-9_6">further methods <br/>
<ul>
<li id="sec-9_6_1"><code>second :: (b ~&gt; c) -&gt; ((d, b) ~&gt; (d, c))</code>: similar to <code>first</code>, but with elements of tuple swapped <br/>
</li>
</ul>
<ul>
<li id="sec-9_6_2"><code>(***) :: (b ~&gt; c) -&gt; (b’ ~&gt; c’) -&gt; ((b, b’) ~&gt; (c, c’))</code>: "parallel composition" of arrows; takes two arrows and turns them into one on tuples (first arrow on first element, second arrow on second element) <br/>
</li>
</ul>
<ul>
<li id="sec-9_6_3"><code>(&amp;&amp;&amp;) :: (b ~&gt; c) -&gt; (b ~&gt; c’) -&gt; (b ~&gt; (c, c’))</code>: "fanout composition"; takes two arrows and makes them into a new arrow which supplies its input to both arrows, returning their results as a tuple <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-9_7">instances <br/>
<ul>
<li id="sec-9_7_1">only two instances in library <br/>
</li>
</ul>
<ul>
<li id="sec-9_7_2"><code>(-&gt;)</code>, the normal function constructor <br/>
</li>
</ul>
<ul>
<li id="sec-9_7_3"><code>Kleisli m</code> which makes functions of type <code>a -&gt; m b</code> into <code>Arrows</code> for any <code>Monad m</code> <br/>
</li>
</ul>
</li>
</ul>
<ul>
<li id="sec-9_8">laws <br/>
<ul>
<li id="sec-9_8_1"><code>arr id = id</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_2"><code>arr (h . g) = arr g &gt;&gt;&gt; arr h</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_3"><code>first (arr g) = arr (g *** id)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_4"><code>first (g &gt;&gt;&gt; h) = first g &gt;&gt;&gt; first h</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_5"><code>first g &gt;&gt;&gt; arr (id ***h ) = arr (id *** h) &gt;&gt;&gt; first g</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_6"><code>first g &gt;&gt;&gt; arr fst = arr fst &gt;&gt;&gt; g</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_7"><code>first (first g) &gt;&gt;&gt; arr assoc = arr assoc &gt;&gt;&gt; first g</code> <br/>
</li>
</ul>
<ul>
<li id="sec-9_8_8"><code>assoc ((x,y),z) = (x,(y,z))</code> <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> ArrowChoice </h2>
<div class="outline-text-2" id="text-10">

<ul>
<li id="sec-10_1">allows for alternate execution paths based on intermediate results <br/>
</li>
</ul>
<ul>
<li id="sec-10_2">methods <br/>
<ul>
<li id="sec-10_2_1"><code>left :: (b ~&gt; c) -&gt; (Either b d ~&gt; Either c d)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_2"><code>right :: (b ~&gt; c) -&gt; (Either d b ~&gt; Either d c)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_3"><code>(+++) :: (b ~&gt; c) -&gt; (b’ ~&gt; c’) -&gt; (Either b b’ ~&gt; Either c c')</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_4"><code>(|||) :: (b ~&gt; d) -&gt; (c ~&gt; d) -&gt; (Either b c ~&gt; d)</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_5">similar to <code>first</code>, <code>second</code>, <code>(***)</code> and <code>(&amp;&amp;&amp;)</code>, but operating on sum types instead of product types (tuples) <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_6">operate on arrows whose inputs are tagged with <code>Left</code> and <code>Right</code> and choose how to act based on that <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_7"><code>left g</code> has the behavior of <code>g</code> for inputs tagged with <code>Left</code> and behaves as the identity for inputs tagged as <code>Right</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_8"><code>right g</code> is the mirror image of <code>left</code> <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_9"><code>(***)</code> performs "multiplexing": <code>g</code> behaves as <code>g</code> for inputs tagged as <code>Left</code> and <code>h</code> behaves as <code>h</code> for inputs tagged as <code>Right</code>; tags are preserved <br/>
</li>
</ul>
<ul>
<li id="sec-10_2_10"><code>(|||)</code> is "merge" or "fanin": like <code>(***)</code> but tags are discarded; mnemonic: <code>g ||| h</code> performs either <code>g</code> <b>or</b> <code>h</code>. <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> ArrowApply </h2>
<div class="outline-text-2" id="text-11">

<ul>
<li id="sec-11_1">more flexible than <code>ArrowChoice</code> <br/>
</li>
</ul>
<ul>
<li id="sec-11_2">can <b>compute</b> an arrow from intermediate results and this computed arrow continues the computation <br/>
</li>
</ul>
<ul>
<li id="sec-11_3">method <br/>
<ul>
<li id="sec-11_3_1"><code>app :: (b ~&gt; c, b) ~&gt; c</code> <br/>
</li>
</ul>
<ul>
<li id="sec-11_3_2">allows us to apply a computed arrow to an input <br/>
</li>
</ul>
<ul>
<li id="sec-11_3_3">this is exactly what monadic bin (<code>(&gt;&gt;=)</code>) does <br/>
</li>
</ul>
<ul>
<li id="sec-11_3_4"><code>ArrowApply</code> and <code>Monad</code> are equivalent in expressive power <br/>
</li>
</ul>
<ul>
<li id="sec-11_3_5">any instance of <code>ArrowApply</code> can be made a <code>Monad</code> via <code>ArrowMonad</code> <br/>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> ArrowLoop </h2>
<div class="outline-text-2" id="text-12">

<ul>
<li id="sec-12_1">describes arrows that can use recursion to compute results <br/>
</li>
</ul>
<ul>
<li id="sec-12_2">used to desugar <code>rec</code> construct in arrow notation <br/>
</li>
</ul>
<ul>
<li id="sec-12_3">GHC has a special arrow notation similar to do-notation that allows to assign names to intermediate results <br/>
</li>
</ul>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Comonad </h2>
<div class="outline-text-2" id="text-13">

<ul>
<li id="sec-13_1">categorical dual of <code>Monad</code> <br/>
</li>
</ul>
<ul>
<li id="sec-13_2"><code>extract</code> is the dual of <code>return</code> <br/>
</li>
</ul>
<ul>
<li id="sec-13_3"><code>duplicate</code> is the dual of <code>join</code> (adds layer of monadic wrapping) <br/>
</li>
</ul>
<ul>
<li id="sec-13_4"><code>extend</code> is the dual of <code>(&gt;&gt;=)</code> with arguments in different order <br/>
</li>
</ul>
<ul>
<li id="sec-13_5">can be defined by <code>fmap</code>, <code>extract</code> and <b>either</b> <code>duplicate</code> or <code>extend</code> <br/>
&lt;a href="<a href="http://flattr.com/thing/350548/The-Typeclassopedia-A-summary">http://flattr.com/thing/350548/The-Typeclassopedia-A-summary</a>"&gt;
&lt;img src="<img src="http://api.flattr.com/button/flattr-badge-large.png"  alt="http://api.flattr.com/button/flattr-badge-large.png" />" alt="Flattr this" title="Flattr this" />&lt;/a&gt;
</li>
</ul>
</div>
</div>
<div id="postamble">
<p class="author">Author: Michael Kohl</p>
<p class="creator">Org version 7.5 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>
</div>
</div>
</body>
</html>
